---
title: Android面经
date: 2020-05-13 17:05:23
tags: Android
categories: Android
---

# Android开发岗个人面经

## 2020-05-13 字节跳动一面

> 这也是我人生中第一次经历的面试，也是第一次的线上面试，总的来说，真的很慌张，而且其实自己也知道准备的是不充分的，但是还是硬着头皮参加了，也算是一种人生经历吧。下面是字节跳动一面时候问到的问题，先列举出来，然后进行一个知识总结与概括：
> + 操作系统中死锁的概念
> + 产生死锁的方式
> + 排序，谈谈有什么排序算法，讲一讲时间复杂度，以及排序的“稳定性”
> + Java中 synchronized 与 Lock 区别
> + 单例模式实现，两种，多线程情况下的考虑
> + Android生命周期解析
> + Activity 之间的跳转生命周期是怎么变化的
> + Android中Handler与Message机制在多线程环境下的消息传输
> + 算法题：排序，有序的数组中找到某一目标值首次出现的下标，如：111122223334455666，问6第一次出现的数组下标为？（不可以用暴力）

**下面是针对面试中提出的问题进行的知识上的储备。**
<!--more-->

### 死锁

两个或多个进程被无限期地阻塞、相互等待的一种状态。

产生的`主要原因`：

+ 系统资源不足
+ 进程推进顺序非法

产生死锁的`必要条件`：

+ 1、互斥条件，一个资源每次只能被一个进程使用。
+ 2、不可抢占条件，进程已获得资源，在未使用完之前不被强行剥夺。
+ 3、占有并等待条件，一个进程因请求资源而阻塞时，对已获得的资源保持不放。
+ 4、环形等待条件，若干进程之间形成一种首尾相接的循环等待资源关系。

`注：`这四个条件缺一不可，只有都满足了，才能够发生死锁。

所以，如何解除死锁的问题，就是只需要破坏上述四个条件中其中一个就可以解决了。

`解决方案`：

+ 打破互斥条件：允许进程同时访问某些资源。————这个方法受制于实际场景，不推荐。
  
+ 打破不可抢占条件：允许进程强行从占有者进程夺取某些资源。简单理解：占有资源的进程不能再申请占有其他资源，必须释放了手上拥有的资源后才能够发起申请。————相同的，不容易找到适用场景。
  
+ 进程再运行前申请得到所有的资源，否则该进程不能进入准备执行状态。————缺点：资源利用率低，并发性低。
  
+ 避免资源申请环路，即事先对资源进行分类编号，按号分配。————优点：有效提高资源的利用率和系统的吞吐量。缺点：加大系统开销，增大了进程对资源的占用时间。

`消除死锁的方式`：

+ 重启系统。————这个代价太大了…………

+ 撤销进程，剥夺资源。终止参与死锁的进程，收回他们的资源。这里又分两种情况：
  
  + 一次性撤销参与死锁的全部进程，剥夺全部资源。
  + 逐步撤销参与的进程，逐步回收死锁进程占有的资源。

+ 进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点继续执行，以求再次执行时不发生死锁。

### synchronized详解、Lock详解

#### synchronized

**作用：** 利用锁的机制来实现同步的。

`锁机制特性：`

互斥性：同一时间只允许一个线程持有某个对象锁。————往往称为操作的原子性。

可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。

##### 对象锁和类锁

+ 对象锁：在Java中，每个对象都会有一个monitor对象，这个就是Java对象的锁————又叫内置锁/对象锁。每个对象都有一个独立的内置锁，互不干扰。

+ 类锁：每个类都有一个类锁。

##### synchronized用法

+ 根据修饰对象分类：
  + 修饰代码块
  + 修饰方法

+ 根据获取的锁分类：
  + 获取对象锁
  + 获取类锁

#### synchronized用法详解




### 排序算法